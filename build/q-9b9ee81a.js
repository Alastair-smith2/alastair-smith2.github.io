import{d as r,k as o,m as e}from"./q-03dc6efe.js";import{A as i,P as s}from"./q-38f98843.js";const d=[{text:"Learnings from cryptopals",id:"learnings-from-cryptopals",level:1},{text:"What is cryptopals? ",id:"what-is-cryptopals-",level:2},{text:'What makes a suitable cryptographic algorithm? The "trapdoor" effect.',id:"what-makes-a-suitable-cryptographic-algorithm-the-trapdoor-effect",level:2},{text:"Diffie-Hellman",id:"diffie-hellman",level:2},{text:"Integer factorisation ",id:"integer-factorisation-",level:2},{text:"Simplified overview of the Elliptic Curve Discrete Logarithm Problem",id:"simplified-overview-of-the-elliptic-curve-discrete-logarithm-problem",level:2},{text:"Why current cryptographic solutions widely used today are secure - for now.",id:"why-current-cryptographic-solutions-widely-used-today-are-secure---for-now",level:2},{text:"A very easy way to shoot yourself in the foot in cryptography - insecure randomness",id:"a-very-easy-way-to-shoot-yourself-in-the-foot-in-cryptography---insecure-randomness",level:2},{text:"Summary ",id:"summary-",level:2}],p={title:"Learnings from cryptopals",meta:[{name:"author",content:"Alastair Smith"},{name:"description",content:"Some lessons learnt from doing the cryptopals challenge"},{property:"og:title",content:"Some lessons learnt from doing the cryptopals challenge"},{property:"og:description",content:"Some lessons learnt from doing the cryptopals challenge"}],styles:[],links:[],frontmatter:{}},u={title:"Learnings from cryptopals",author:"Alastair Smith",description:"Some lessons learnt from doing the cryptopals challenge",og:[{title:"Some lessons learnt from doing the cryptopals challenge",description:!0}]};function a(n){const t=Object.assign({h1:"h1",a:"a",span:"span",ol:"ol",li:"li",h2:"h2",p:"p",pre:"pre",code:"code"},n.components);return e(s,{children:[e(t.h1,{id:"learnings-from-cryptopals",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#learnings-from-cryptopals",children:e(t.span,{class:"icon icon-link"})}),"Learnings from cryptopals"]}),e(t.ol,{children:[`
`,e(t.li,{children:e(t.a,{href:"#cryptopals",children:"What is cryptopals?"})}),`
`,e(t.li,{children:e(t.a,{href:"#trapdoor",children:"What makes a good cryptographic algorithm?"})}),`
`,e(t.li,{children:e(t.a,{href:"#diffie-hellman",children:"Diffie-Hellman"})}),`
`,e(t.li,{children:e(t.a,{href:"#integer-factorisation",children:"Integer factorisation"})}),`
`,e(t.li,{children:e(t.a,{href:"#ecdlp",children:"Elliptic curve discrete logarithm problem"})}),`
`,e(t.li,{children:e(t.a,{href:"#secure-for-now",children:"Why current cryptographic algorithms are secure - for now"})}),`
`,e(t.li,{children:e(t.a,{href:"#insecure-randomness",children:"Insecure randomness"})}),`
`,e(t.li,{children:e(t.a,{href:"#summary",children:"Summary"})}),`
`]}),e(t.h2,{id:"what-is-cryptopals-",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#what-is-cryptopals-",children:e(t.span,{class:"icon icon-link"})}),"What is cryptopals? ",e("a",{name:"cryptopals"})]}),e(t.p,{children:["At first glance people could be mistaken for thinking this post is going to be related to cryptocurrency, but that is not the case. ",e(i,{text:"Cryptopals",href:"https://cryptopals.com/"})," is a series of challenges that relate to cryptography. Cryptography is essential to the modern internet; it helps provide security by preventing others from intercepting communication that is intended to be private, and is fundamental to efforts like ",e(i,{text:"ending the need for passwords.",href:"https://blog.google/technology/safety-security/the-beginning-of-the-end-of-the-password/"})," The challenges on cryptopals help you learn about cryptography by providing problems that demonstrate how real-world attacks work against various algorithms. This post is some of my learnings from the cryptopals challenges and wider reading."]}),e("a",{name:"trapdoor"}),e(t.h2,{id:"what-makes-a-suitable-cryptographic-algorithm-the-trapdoor-effect",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#what-makes-a-suitable-cryptographic-algorithm-the-trapdoor-effect",children:e(t.span,{class:"icon icon-link"})}),'What makes a suitable cryptographic algorithm? The "trapdoor" effect.']}),e(t.p,{children:['Cryptography heavily relies upon various "hard" maths problems. These problems which, unless you have some secret information, can take a computer a very very long time (',e(i,{text:"in some cases trillions of years",href:"https://www.quintessencelabs.com/blog/breaking-rsa-encryption-update-state-art"}),") to solve. These are ",e(i,{text:"trapdoor functions",href:"https://en.wikipedia.org/wiki/Trapdoor_function"})," - they make it easy to produce a result in one direction but incredibly difficult to produce the inverse without some secret information. Let’s look at an algorithm and how it leverages this."]}),e("a",{name:"diffie-hellman"}),e(t.h2,{id:"diffie-hellman",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#diffie-hellman",children:e(t.span,{class:"icon icon-link"})}),"Diffie-Hellman"]}),e(t.p,{children:[e(i,{text:"Diffie-Hellman",href:"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#"})," (DH) as an algorithm which paved the way for exchanging ",e(i,{href:"https://en.wikipedia.org/wiki/Key_(cryptography)",text:"cryptographic keys"}),` securely between parties who may never have had contact before, by establishing
a joint secret. `,e(i,{text:"Wikipedia",href:"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"}),`
has an excellent analogy:`]}),e("img",{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/250px-Diffie-Hellman_Key_Exchange.svg.png",style:"background-color: white; margin: 2rem auto;"})," ",e(t.p,{children:"The trapdoor effect here can be seen because even though the common paint and initial mixture are available for all to see, the mixture process is incredibly hard to reverse. This means the secret colour can't be derived from the public information alone. The clever part in DH is that both parties can mix their secret colour with the other’s initial mixture to come up with the same secret."}),e(t.p,{children:"In reality very large numbers are used instead of paint."}),e(t.p,{children:"Let's look at an example equation which I have filled with simple numbers:"}),e(t.p,{children:["2",e("sup",{children:"x"}),"(mod 7) = 2"]}),e(t.p,{children:["The difficulty here is trying to find X (the exponent). In plain English, this equation is asking, what is the number that when 2 is raised to X and then divided by 7, has the remainder 2? This is simple to find for small numbers, but with large numbers it becomes very hard for computers to fathom. This is the ",e(i,{text:"discrete logarithm problem",href:"https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/discrete-logarithm-problem"}),". In the DH example above the common numbers (e.g. 2 and 7) are agreed by Alice and Bob in advance. Each individual then performs the aforementioned equation with a chosen secret as the exponent. Next, each individual shares the resulting value and then performs the operation again but this time using the resulting value from the other as the number to be raised by their secret. In the end they both end up with the same number that can be used as a secret for secure communication! I enjoyed learning the maths behind this one. It was also interesting learning how to use this maths concretely in a programming language - I had been using Rust for the challenges and there's a convenient package that has the ",e(i,{text:"modpow operation",href:"https://docs.rs/num-bigint/latest/num_bigint/struct.BigUint.html#method.modpow"}),"."]}),e(t.p,{children:`Let's delve a bit deeper into some other maths that is leveraged to create the "trapdoor" effect in modern algorithms.`}),e(t.h2,{id:"integer-factorisation-",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#integer-factorisation-",children:e(t.span,{class:"icon icon-link"})}),"Integer factorisation ",e("a",{name:"integer-factorisation"})]}),e(t.p,{children:["Given the number 713, can you tell me what its prime factors are without using a computer? By trial and error eventually you’d calculate that they were 23 and 31. But what if I gave you the number 843151 and said I was looking for the two specific prime factors that multiply together to make that number? By hand you’d likely not bother but maybe you’d google it. On the other hand, what if I had asked for the result of multiplying 863 and 977 together? That is easy: the number is 843151. This maths - integer factorisation using primes only - is at the heart of the popular ",e(i,{text:"RSA algorithm",href:"https://en.wikipedia.org/wiki/RSA_(cryptosystem)"})," that is widely used for secure communication. Part of the RSA algorithm is generating a number (N, which is used as a modulus in the algorithm and shared publicly) from two very large prime numbers. In real life the prime numbers are hundreds of digits long. If the prime numbers could easily be derived from N, the RSA algorithm would be rendered insecure because the private key - which is used to decrypt messages that are encrypted with the public key - could be derived. For current RSA-2048 bit encryption keys it would take a ",e(i,{text:"computer ~300 trillion years",href:"https://www.quintessencelabs.com/blog/breaking-rsa-encryption-update-state-art"})," to find the prime numbers. There are ways to attack RSA if the prime numbers are too small or too close together."]}),e("a",{name:"ecdlp"}),e(t.h2,{id:"simplified-overview-of-the-elliptic-curve-discrete-logarithm-problem",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#simplified-overview-of-the-elliptic-curve-discrete-logarithm-problem",children:e(t.span,{class:"icon icon-link"})}),"Simplified overview of the Elliptic Curve Discrete Logarithm Problem"]}),e(t.p,{children:['This section we’ll be looking at some maths involved in Elliptic Curve Cryptography (ECC). Hopefully upon completing this section you’ll feel like you understand a simplified explanation of the "hard" maths problem at the core of ECC. An elliptic curve satisfies the equation y',e("sup",{children:"2"})," = x",e("sup",{children:"3"})," + ax + b and is symmetrical across the x-axis. For our purposes, the top right curve on the diagram below is the most helpful image."]}),e("img",{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/EllipticCurveCatalog.svg/800px-EllipticCurveCatalog.svg.png",style:"background-color: white; margin: 2rem auto;"}),e(t.p,{children:[`An interesting problem they present is represented in the form of an equation nP = E, where the value n here is the number
of times point P was "dotted" on a curve. Before explaining what "dotted" means, a
key piece of information is this: for two given points on a curve (e.g. our starting
points A and B, which will both be on one side of the x-axis) there will always be at most a third point. What this means is for our
starting point we can find the third point - C - on the curve, by drawing a straight
line through A and B. Once we’ve found where this line intercepts on the curve, we
find the corresponding point of the curve on the other side of the x-axis and this
becomes C. Now we repeat the process using A and C as our two points to find where
the next part of the graph is intercepted and flip over the x-axis again to find D. If you’d like
to see a visual representation of this process `,e(i,{text:"this video",href:"https://www.youtube.com/watch?v=gAtBM06xwaw"}),` is an excellent resource. This process,
which is the adding of a point to itself, is often referred to "dotting". Formally, this is called `,e(i,{text:"Elliptic curve point multiplication",href:"https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication"}),`
and the number of times we "dot" becomes our private key (n). E is the result of
how many times we "dotted" the starting point P. Finding n from E and P is incredibly
difficult but finding E from n and P is simple for computers. This problem is known
as the Elliptic Curve Discrete Logarithm Problem (ECDLP) and is a form of the discrete
logarithm problem we saw earlier.`]}),e(t.p,{children:[`An interesting point about elliptic curves in comparison to algorithms like RSA is for numbers of
the same size they essentially give us more "bang for our buck" in terms of security.
According to this `,e(i,{text:"paper",href:"https://eprint.iacr.org/2013/635.pdf"}),` (which has the analogy of how much water you’d need to bring to a boil for the idea
of difficulty or "security") it only takes a 210-bit elliptic curve key to match
a 1990-bit RSA key, hence why algorithms like `,e(i,{text:"ECDSA",href:"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"}),`
are popular.`]}),e("a",{name:"secure-for-now"}),e(t.h2,{id:"why-current-cryptographic-solutions-widely-used-today-are-secure---for-now",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#why-current-cryptographic-solutions-widely-used-today-are-secure---for-now",children:e(t.span,{class:"icon icon-link"})}),"Why current cryptographic solutions widely used today are secure - for now."]}),e(t.p,{children:["While these algorithms are popular today, they are almost certainly going to be replaced in the future due to ",e(i,{text:"quantum computers",href:"https://blog.cloudflare.com/towards-post-quantum-cryptography-in-tls/"}),". A quantum computer could execute algorithms (",e(i,{text:"Shor’s algorithm",href:"https://quantum-computing.ibm.com/composer/docs/iqx/guide/shors-algorithm"}),' is the most relevant to this post) which would be able to solve the "hard" problems discussed here in a matter of seconds or minutes. Quantum computers will essentially render current cryptographic algorithms useless, so nothing would be secure. Thankfully there has been a lot of work already done to solve this problem with the development of post-quantum algorithms. ',e(i,{text:"This blog post",href:"https://blog.cloudflare.com/nist-post-quantum-surprise/"})," gives a detailed walkthrough of various algorithms with their various trade-offs, and outlines which ones are being standardised, for those who are interested."]}),e("a",{name:"insecure-randomness"}),e(t.h2,{id:"a-very-easy-way-to-shoot-yourself-in-the-foot-in-cryptography---insecure-randomness",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#a-very-easy-way-to-shoot-yourself-in-the-foot-in-cryptography---insecure-randomness",children:e(t.span,{class:"icon icon-link"})}),"A very easy way to shoot yourself in the foot in cryptography - insecure randomness"]}),e(t.p,{children:['Cryptography needs a degree of randomness. One example is that if the same word, e.g. "hello", always produced the same ciphertext (the output of the message into an encryption function) then it would be very easy to decipher messages over time. This is because an attacker could build a dictionary of how plaintext relates to ciphertext. Pseudo-Random Number Generators (PRNGs) are often used to approximate randomness in programs but are highly predictable because the sequence of numbers they produce is based off a seed. The trouble comes in when PRNGs are used for cryptographic purposes because suddenly what should be seemingly random, isn’t. For example, ',e(i,{text:"OWASP",href:"https://owasp.org/www-community/vulnerabilities/Insecure_Randomness"})," give a great example where a receipt URL is generated using a PRNG for part of the URL with the current time as the seed:"]}),e(t.pre,{children:e(t.code,{class:"language-java",children:[e(t.span,{class:"token class-name",children:"String"})," ",e(t.span,{class:"token function",children:"generateReceiptURL"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token class-name",children:"String"})," baseUrl",e(t.span,{class:"token punctuation",children:")"})," ",e(t.span,{class:"token punctuation",children:"{"}),`
    `,e(t.span,{class:"token class-name",children:"Random"})," ranGen ",e(t.span,{class:"token operator",children:"="})," ",e(t.span,{class:"token keyword",children:"new"})," ",e(t.span,{class:"token class-name",children:"Random"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:";"}),`
    ranGen`,e(t.span,{class:"token punctuation",children:"."}),e(t.span,{class:"token function",children:"setSeed"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token keyword",children:"new"})," ",e(t.span,{class:"token class-name",children:"Date"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:"."}),e(t.span,{class:"token function",children:"getTime"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:";"}),`
    `,e(t.span,{class:"token keyword",children:"return"}),e(t.span,{class:"token punctuation",children:"("}),"baseUrl ",e(t.span,{class:"token operator",children:"+"})," ",e(t.span,{class:"token class-name",children:"Gen"}),e(t.span,{class:"token punctuation",children:"."}),e(t.span,{class:"token function",children:"nextInt"}),e(t.span,{class:"token punctuation",children:"("}),e(t.span,{class:"token number",children:"400000000"}),e(t.span,{class:"token punctuation",children:")"})," ",e(t.span,{class:"token operator",children:"+"})," ",e(t.span,{class:"token string",children:'".html"'}),e(t.span,{class:"token punctuation",children:")"}),e(t.span,{class:"token punctuation",children:";"}),`
`,e(t.span,{class:"token punctuation",children:"}"}),`
`]})}),e(t.p,{children:"The problem here is that if an attacker determined that a specific time was the seed for the URL then it’s possible for them a) identify other receipt URLs by brute forcing time ranges and b) predict future valid URLs based on a given time. Instead, Cryptographic Pseudo-Random Number Generators (CPRNGs) are designed for these scenarios because they are not predictable in the same manner - these should be used rather than PRNGs."}),e(t.p,{children:["There are algorithms that depend upon an initialisation vector (IV) for randomness to ensure repeated words do not produce repeated cipher text as described earlier. Using an inappropriate PRNG that repeats values with these algorithms in some circumstances ",e(i,{text:"can actually lead to attackers being able to determine the plaintext of a ciphertext",href:"https://stackered.com/blog/iv-mishandling/"})," without the encryption key. From a security perspective this would be disastrous."]}),e(t.h2,{id:"summary-",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#summary-",children:e(t.span,{class:"icon icon-link"})}),"Summary ",e("a",{name:"summary"})]}),e(t.p,{children:`I really enjoyed (and at times found very frustrating) some of the cryptopals challenges. I've learned a lot about cryptography which I didn't know before, such as the inner workings of various algorithms and some of the "hard" maths problems involved. There are many elements (e.g. the inner workings of elliptic curves) that I would not dare claim to be an expert about but I have a lot more working knowledge and points of reference than I did when I started cryptopals.`}),e(t.p,{children:"I ran into a situation recently where upgrading a dependency highlighted the use of an algorithm that is no longer fit for purpose. Having looked up the algorithm, it was very rewarding to see that some of the knowledge I had picked up through the cryptopals challenges was directly relevant. I ended up having a good discussion with some of my colleagues off the back of it."})]})}function h(n={}){const{wrapper:t}=n.components||{};return t?e(t,Object.assign({},n,{children:e(a,n)})):a(n)}const m=()=>r(o,{children:r(h,{},3,null)},3,"8oVwirYX");export{m as default,u as frontmatter,p as head,d as headings};
