import{d as i,w as r,t as e}from"./q-aabf3092.js";import{A as n,P as s}from"./q-00b387ef.js";const c=[{text:"Major version upgrades: Dreaming of what could be normal",id:"major-version-upgrades-dreaming-of-what-could-be-normal",level:1},{text:"What I've been doing recently",id:"what-ive-been-doing-recently",level:2},{text:"The cost of maintenance?",id:"the-cost-of-maintenance",level:2},{text:"The norm",id:"the-norm",level:2},{text:"What could be",id:"what-could-be",level:2},{text:"Wrapping up",id:"wrapping-up",level:2}],u={title:"Major Version Upgrades",meta:[{name:"author",content:"Alastair Smith"},{name:"description",content:"Some reflections on what major version upgrades could look like"},{property:"og:title",content:"Some reflections on what major version upgrades could look like"},{property:"og:description",content:"Some reflections on what major version upgrades could look like"}],styles:[],links:[],scripts:[],frontmatter:{Date:"05/11/2023"}},m={title:"Major Version Upgrades",author:"Alastair Smith",description:"Some reflections on what major version upgrades could look like",Date:"05/11/2023",og:[{title:"Some reflections on what major version upgrades could look like",description:!0}]};function o(a){const t=Object.assign({h1:"h1",a:"a",span:"span",ol:"ol",li:"li",h2:"h2",p:"p",em:"em",blockquote:"blockquote",strong:"strong"},a.components);return e(s,{children:[e(t.h1,{id:"major-version-upgrades-dreaming-of-what-could-be-normal",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#major-version-upgrades-dreaming-of-what-could-be-normal",children:e(t.span,{class:"icon icon-link"})}),"Major version upgrades: Dreaming of what could be normal"]}),e(t.ol,{children:[`
`,e(t.li,{children:e(t.a,{href:"#what-ive-been-doing-recently",children:"What I've been doing recently"})}),`
`,e(t.li,{children:e(t.a,{href:"#the-cost-of-maintenance",children:"The cost of maintenance"})}),`
`,e(t.li,{children:e(t.a,{href:"#the-norm",children:"The norm"})}),`
`,e(t.li,{children:e(t.a,{href:"#what-could-be",children:"What could be"})}),`
`,e(t.li,{children:e(t.a,{href:"#wrapping-up",children:"Wrapping up"})}),`
`]}),e(t.h2,{id:"what-ive-been-doing-recently",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#what-ive-been-doing-recently",children:e(t.span,{class:"icon icon-link"})}),"What I've been doing recently",e("a",{name:"what-ive-been-doing-recently"})]}),e(t.p,{children:["The team I work with have recently upgraded the framework, ",e(n,{text:"React Native",href:"https://reactnative.dev/"})," (RN), which we use to build and maintain a mobile app. Our goal was to get it to the latest stable version at the time which happened to be 0.72.4. In fact, upgrading RN is something I’ve done several times in a previous role so I am familiar with the process. Since I last did this, ",e(n,{text:" there is even better tooling",href:" https://reactnative.dev/docs/upgrading#react-native-projects"}),". RN’s versioning is a bit strange; see ",e(n,{text:"this issue",href:"https://github.com/facebook/react-native/issues/16846"})," for more details. So far, there is nothing out of the ordinary in this situation. What gives?"]}),e(t.p,{children:["This: In my prior context I can’t remember ever doing an upgrade that was more than 2 (maybe 3?) major versions of RN. What we did was 12 major versions. Yes, ",e(t.em,{children:"12 major versions"}),". This article is a reflection of the process of major version upgrades and an imagining of what could be more normal. I’ll primarily refer to frameworks in this article but lots of the points could also be said for libraries."]}),e(t.h2,{id:"the-cost-of-maintenance",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#the-cost-of-maintenance",children:e(t.span,{class:"icon icon-link"})}),"The cost of maintenance?",e("a",{name:"the-cost-of-maintenance"})]}),e(t.p,{children:"Anyone who has been involved in building, running and maintaining non-trivial software (whatever the role) over a long enough period will eventually be exposed to the discussion of “the framework we use to build this software needs to be updated”. Normally there are some groans as people realise some of what this commonly entails:"}),e(t.ol,{children:[`
`,e(t.li,{children:"Engineering want a period of time (often non-insignificant) to do the update. Ideally without doing feature work which will otherwise cause additional overhead. There’s also a risk further work will be identified as needing done (e.g. dependency incompatibilities) once the work commences."}),`
`,e(t.li,{children:"Product timelines are going to be impacted, regardless of the approach, which has some negative implication."}),`
`,e(t.li,{children:"There is a risk that the software being maintained will break in some way that won’t be caught in the upgrade."}),`
`]}),e(t.p,{children:"But why does this “need” to happen? That in of itself is an interesting point. Points 2-4 are most relevant to the context I am in but some common reasons are:"}),e(t.ol,{children:[`
`,e(t.li,{children:"A non-backwards compatible security update is only available in a later version of the framework."}),`
`,e(t.li,{children:"There are updates in the framework that will have benefits when it comes to maintaining the software, e.g. the new or previous functionality is now easier to use. Another example is if there are bugs in the framework, they will not always be back-ported to older versions, whilst they are more likely to be addressed in the current version / a select number of older versions."}),`
`,e(t.li,{children:"The libraries that engineers use to develop functionality will often look to support newer versions of frameworks. Libraries may only have the newer features, the ones desired, on a later version that you can’t use due to the framework version you’re on or some similar reason. Supporting every version of the framework from a maintainer perspective is often an unacceptable overhead of work, will lead to diminishing returns, or is impossible."}),`
`,e(t.li,{children:"There are performance benefits for the end user"}),`
`]}),e(t.p,{children:"Major version upgrades are an inevitable part of the parcel when it comes to maintaining software. There is a cost to just keeping the lights on over time, which includes maintenance work."}),e(t.p,{children:["Side note - I’ve sometimes heard people refer to this as a form of “tech debt”. If you haven’t already ",e(n,{text:"I’d highly recommend this series",href:"https://chelseatroy.com/2021/01/14/quantifying-technical-debt/"})," by Chelsea Troy which has some excellent points on the topic of just “keeping the lights on” in software. It changed my opinion on the term “tech debt”."]}),e(t.h2,{id:"the-norm",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#the-norm",children:e(t.span,{class:"icon icon-link"})}),"The norm",e("a",{name:"the-norm"})]}),e(t.p,{children:["My experience of major version upgrades has always involved feature branches. ",e(n,{text:"This seems to be the norm",href:"https://remix.run/blog/future-flags#status-quo"}),". As such you normally end up with a ton of work to do and if you’re lucky you’re not working against a moving target. If you are working against a moving target then you have an additional overhead of migrating any new work at minimum, and likely resolving conflicts. But the article also has an excellent insight: commonly,"]}),e(t.blockquote,{children:[`
`,e(t.p,{children:`developers are still left with a "here's all the new stuff at once" dump in a major version - leaving them to play catch-up for a period of time.`}),`
`]}),e(t.p,{children:["If there's one piece of wisdom I’ve learned from others, is that wherever possible, ",e(t.strong,{children:"attempt to work iteratively"}),". The article above, encouragingly, cites this as a common factor in successful upgrade stories. When introducing small changes to a codebase iteratively it significantly reduces the likelihood of risk as only a smaller subset of changes are being introduced. This reduces the blast radius of any unintended side effects. It also makes the cognitive burden of others reviewing any such change easier because again the context to understand the change is easier to grasp. But when it comes to major version upgrades this is often not a possible because of the issue raised in the quote above: you get dumped with a bunch of changes which you have to resolve all at once unless you want to risk breaking the branch that others are working from. Having the main branch in a broken state for me is a no go as it should always be releasable. A set of well maintained tests at varying levels would help here but again whether you have these will depend on your context. One option is to develop a set of tests (if absent) before you set out on a major version upgrade. But what if you didn’t have to be dumped with all the new breaking changes at once?"]}),e(t.h2,{id:"what-could-be",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#what-could-be",children:e(t.span,{class:"icon icon-link"})}),"What could be",e("a",{name:"what-could-be"})]}),e(t.p,{children:["Again I’ll refer to same ",e(n,{text:"article",href:"https://remix.run/blog/future-flags#introducing-future-flags"}),", but if the concept of “future flags” were widespread, the experience could be drastically different for consumers of frameworks. Future flags, AKA ",e(t.strong,{children:'"feature flags for future features”'}),", allow consumers of a framework to iteratively adopt future features when so desired. The exact details are framework specific but in Remix you have the possibility configure what future flags you want to be enabled. With this approach you could avoid having to deal with every breaking change simultaneously when you decided to opt into migrating a feature. For a non-trivial application, whilst integrating even a singular change (whether directly on trunk or via a pull request) would still be quite large, it could be a magnitude of size smaller than integrating every breaking change. This enables the work to be done iteratively, in smaller batches, and makes is appealing to be done in business as usual activity. That is hugely appealing in my eyes."]}),e(t.p,{children:["A key point worth mentioning however is that a complexity has essentially been shifted onto the maintainers of the framework. This is one reason why I find the Remix team’s ambition in this regard admirable but also potentially important in retaining developers. I’d be surprised to see future flags become mainstream within open source software (OSS) more widely however. OSS is already challenging enough without shifting more complexity towards the maintainers. One aspect that I think is more feasible is the way that engineering teams could leverage this approach internally. If you have a shared package that is used by others then this is definitely an approach that could be leveraged. In one sense I’d actually argue that it’s more emphatic to end consumers of the package, who are other engineers, and who won’t just get dumped with a variety of breaking changes. At that point, communication is arguably the most important item that needs to happen but I could imagine future flags helping. The Remix team have done an excellent job on documenting their process around future flags, how they have exposed the flags, the process involved in deciding to create a flag etc. It can be found ",e(n,{text:"here",href:"https://remix.run/docs/en/main/pages/api-development-strategy"})," for those interested."]}),e(t.h2,{id:"wrapping-up",children:[e(t.a,{"aria-hidden":"true",tabindex:"-1",href:"#wrapping-up",children:e(t.span,{class:"icon icon-link"})}),"Wrapping up",e("a",{name:"wrapping-up"})]}),e(t.p,{children:"There were a couple of issues that came out after the upgrade. It highlighted some processes that need to be more robust and some areas, which although challenging, need better automation. The team did an excellent job on the RN upgrade and in our context has opened the avenue for various other improvements. The number of major versions we upgraded is a situation I’d recommend to everyone to avoid and do regularly housekeeping of major version upgrades wherever possible. With that being said however, the current structure that lots of frameworks use to release major versions is understandably painful for developers. This often results in such upgrades being put off due to risk, complexity and timing. Ironically enough that creates more risk - what if all of a sudden an urgent security update is required at an inconvenient time, or with potential effects for end users? Maintainers understandably don’t want to be doing major version releases frequently, if for no other reason it risks their framework being perceived as unstable, but batching breaking changes also causes pain for those who use the framework by being unable to introduce the changes iteratively. Future flags, while adding complexity for maintainers, allow for iteratively working on breaking changes for engineers. As someone who builds software using frameworks, it would radically change the discussion around major version upgrades if future flags more widely available."})]})}function h(a={}){const{wrapper:t}=a.components||{};return t?e(t,Object.assign({},a,{children:e(o,a)})):o(a)}const g=()=>i(r,{children:i(h,{},3,null)},3,"0gqE2PrL");export{g as default,m as frontmatter,u as head,c as headings};
